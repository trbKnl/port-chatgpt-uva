{"version":3,"file":"static/js/565.3155b6fb.chunk.js","mappings":"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","sources":["../../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../../../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","components/consent_form_viz/visualization_plugin/visualizationDataFunctions/util.ts","components/consent_form_viz/visualization_plugin/visualizationDataFunctions/prepareChartData.ts","components/consent_form_viz/visualization_plugin/visualizationDataFunctions/prepareTextData.ts","components/consent_form_viz/visualization_plugin/visualizationDataFunctions/visualizationDataWorker.ts"],"sourcesContent":["export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nexport default function _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import { DateFormat, Table } from \"../types\";\n\nexport function formatDate(\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString;\n  const dateNumbers = dateString.map((date) => new Date(date).getTime());\n  let domain: [number, number] | null = null;\n  let formatter: (date: Date) => string = (date) => date.toISOString();\n\n  if (format === \"auto\") format = autoFormatDate(dateNumbers, minValues);\n\n  if (format === \"year\") formatter = (date) => date.getFullYear().toString();\n\n  if (format === \"quarter\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const quarter = Math.floor(date.getMonth() / 3) + 1;\n      return `${year}-Q${quarter}`;\n    };\n  }\n\n  if (format === \"month\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      return `${year}-${month}`;\n    };\n  }\n\n  if (format === \"day\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      return `${year}-${month}-${day}`;\n    };\n  }\n\n  if (format === \"hour\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      const hour = date.getHours();\n      return `${year}-${month}-${day} ${hour}:00`;\n    };\n  }\n\n  if (format === \"month_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { month: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any year, starting at january\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2001-01-01\").getTime()];\n  }\n  if (format === \"weekday_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { weekday: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any full week, starting at monday\n    domain = [new Date(\"2023-11-06\").getTime(), new Date(\"2023-11-13\").getTime()];\n  }\n  if (format === \"hour_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { hour: \"numeric\", hour12: false });\n      return intlFormatter.format(date);\n    };\n    // can be any day, starting at midnight\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2000-01-02\").getTime()];\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)));\n  if (domain == null) domain = getDomain(dateNumbers);\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter);\n\n  return [formattedDate, sortableDate];\n}\n\nfunction autoFormatDate(dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers);\n\n  let autoFormat: DateFormat = \"hour\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = \"day\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = \"month\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = \"quarter\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = \"year\";\n\n  return autoFormat;\n}\n\nfunction createSortable(\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {};\n  const [minTime, maxTime] = domain;\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0;\n  if (interval === \"year\") intervalNumber = 1000 * 60 * 60 * 24 * 364;\n  if (interval === \"quarter\") intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3;\n  if ([\"month\", \"month_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28;\n  if ([\"day\", \"weekday_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24;\n  if ([\"hour\", \"hour_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60;\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i);\n      const datestring = formatter(date);\n      if (sortable[datestring] !== undefined) continue;\n      sortable[datestring] = i;\n    }\n  }\n\n  return sortable;\n}\n\nfunction getDomain(numbers: number[]): [number, number] {\n  let min = numbers[0];\n  let max = numbers[0];\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr;\n    if (nr > max) max = nr;\n  });\n  return [min, max];\n}\n\nexport function tokenize(text: string): string[] {\n  const tokens = text.split(\" \");\n  return tokens.filter((token) => /\\p{L}/giu.test(token)); // only tokens with word characters\n}\n\nexport function getTableColumn(table: Table, column: string): string[] {\n  if (column === \".COUNT\") {\n    // special case: just return array with values of 1\n    return Array(table.body.rows.length).fill(\"1\");\n  }\n  const columnIndex = table.head.cells.findIndex((cell) => cell === column);\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`);\n  return table.body.rows.map((row) => row.cells[columnIndex]);\n}\n\nexport function rescaleToRange(value: number, min: number, max: number, newMin: number, newMax: number): number {\n  let scaled = (value - min) / (max - min);\n  scaled = isNaN(scaled) ? 0 : scaled; // prevent NaN\n  return scaled * (newMax - newMin) + newMin;\n}\n\nexport function extractUrlDomain(x: string): string {\n  let domain;\n  try {\n    const url = new URL(x);\n    domain = url.hostname.replace(/^www\\./, \"\").replace(/^m\\./, \"\");\n  } catch (_) {\n    domain = x;\n  }\n  return domain.trim();\n}\n","import { formatDate, getTableColumn } from './util'\nimport { Table, TickerFormat, ChartVisualizationData, ChartVisualization, AxisSettings } from '../types'\n\nexport async function prepareChartData (\n  table: Table,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return { type: visualization.type, xKey: '', xLabel: '', yKeys: {}, data: [] }\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(table, visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  table: Table,\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = initializeVisualizationData(table, visualization)\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xKey]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction initializeVisualizationData (table: Table, visualization: ChartVisualization): ChartVisualizationData {\n  const yKeys: Record<string, AxisSettings> = {}\n  for (const value of visualization.values) {\n    let tickerFormat: TickerFormat = 'default'\n    if (value.aggregate === 'pct' || value.aggregate === 'count_pct') tickerFormat = 'percent'\n\n    if (value.group_by === undefined) {\n      const label = value.label !== undefined ? value.label : value.column\n      yKeys[value.column] = { id: value.column, label, tickerFormat }\n    } else {\n      const uniqueValues = Array.from(new Set(getTableColumn(table, value.group_by)))\n      for (const uniqueValue of uniqueValues) {\n        const id = `${value.column}.GROUP_BY.${uniqueValue}`\n        yKeys[id] = { id, label: uniqueValue, tickerFormat }\n      }\n    }\n  }\n\n  return {\n    type: visualization.type,\n    xKey: visualization.group.column,\n    xLabel: visualization.group.label,\n    yKeys,\n    data: []\n  }\n}\n\nfunction aggregateData (table: Table, visualization: ChartVisualization): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xKey = visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xKey,\n        xValue: uniqueValue,\n        values: {}\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by\n    // column values. As suffix we use the value column, separated with .GROUP_BY.. This is used\n    // so that we can relate the aggregated data back to the value specification\n    let yGroup: null | string[] = null\n    if (value.group_by !== undefined) { yGroup = getTableColumn(table, value.group_by).map((v) => `${value.column}.GROUP_BY.${v}`) }\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (Number(xValue) < visualization.group.range[0] || Number(xValue) > visualization.group.range[1]) {\n          continue\n        }\n      }\n\n      const yValue = yValues[i]\n      const group = yGroup != null ? yGroup[i] : value.column\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xKey,\n          xValue: String(xValue),\n          values: {}\n        }\n      }\n\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] = Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: Table,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xKey: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  tickerFormat?: TickerFormat\n}\n","import { extractUrlDomain, getTableColumn, tokenize } from './util'\nimport { TextVisualizationData, TextVisualization, ScoredTerm, Table } from '../types'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (table: Table, visualization: TextVisualization): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values = visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens = visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (let token of tokens) {\n      if (visualization.extract === 'url_domain') token = extractUrlDomain(token)\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n\n      const v = values != null ? Number(values[i]) ?? 1 : 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (vocabulary: Record<string, VocabularyStats>, nDocs: number, topTerms: number): ScoredTerm[] {\n  return Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = stats.value\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n}\n","import { ChartVisualization, TextVisualization, VisualizationType, VisualizationData, Table } from '../types'\nimport { prepareChartData } from './prepareChartData'\nimport { prepareTextData } from './prepareTextData'\n\ninterface Input {\n  table: Table\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (table: Table, visualization: VisualizationType): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","_toPropertyKey","arg","key","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","arguments","length","forEach","obj","value","defineProperty","configurable","writable","getOwnPropertyDescriptors","defineProperties","formatDate","dateString","format","minValues","formattedDate","dateNumbers","map","date","Date","getTime","domain","formatter","toISOString","minTime","maxTime","getDomain","autoFormat","autoFormatDate","getFullYear","toString","year","quarter","Math","floor","getMonth","concat","month","toLocaleString","day","getDate","hour","getHours","Intl","DateTimeFormat","weekday","hour12","sortableDate","interval","sortable","intervalNumber","includes","i","datestring","createSortable","numbers","min","max","nr","tokenize","text","split","token","test","getTableColumn","table","column","Array","body","rows","fill","columnIndex","head","cells","findIndex","cell","Error","id","row","extractUrlDomain","x","URL","hostname","replace","_","trim","async","prepareChartData","visualization","type","xKey","xLabel","yKeys","data","aggregate","groupBy","xSortable","group","dateFormat","levels","prepareX","rowIds","anyAddZeroes","values","some","addZeroes","uniqueValue","sortby","entries","sortBy","xValue","_value$addZeroes","aggFun","yValues","yGroup","group_by","v","groupSummary","_Number","range","yValue","_Number2","n","sum","aggregateData","visualizationData","tickerFormat","label","uniqueValues","from","Set","initializeVisualizationData","sort","a","b","d","round","_objectSpread","__rowIds","__sortBy","createVisualizationData","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","extract","docFreq","has","add","isNaN","getVocabulary","valueColumn","nDocs","_ref","stats","tf","idf","log","importance","slice","getTopTerms","self","onmessage","then","postMessage","status","catch","error","console"],"sourceRoot":""}