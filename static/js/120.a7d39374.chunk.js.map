{"version":3,"file":"static/js/120.a7d39374.chunk.js","mappings":"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","sources":["framework/visualisation/react/ui/visualization_plugin/visualizationDataFunctions/util.ts","framework/visualisation/react/ui/visualization_plugin/visualizationDataFunctions/prepareChartData.ts","framework/visualisation/react/ui/visualization_plugin/visualizationDataFunctions/prepareTextData.ts","framework/visualisation/react/ui/visualization_plugin/visualizationDataFunctions/visualizationDataWorker.ts"],"sourcesContent":["import { DateFormat, Table } from \"../types\";\n\nexport function formatDate(\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString;\n  const dateNumbers = dateString.map((date) => new Date(date).getTime());\n  let domain: [number, number] | null = null;\n  let formatter: (date: Date) => string = (date) => date.toISOString();\n\n  if (format === \"auto\") format = autoFormatDate(dateNumbers, minValues);\n\n  if (format === \"year\") formatter = (date) => date.getFullYear().toString();\n\n  if (format === \"quarter\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const quarter = Math.floor(date.getMonth() / 3) + 1;\n      return `${year}-Q${quarter}`;\n    };\n  }\n\n  if (format === \"month\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      return `${year}-${month}`;\n    };\n  }\n\n  if (format === \"day\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      return `${year}-${month}-${day}`;\n    };\n  }\n\n  if (format === \"hour\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      const hour = date.getHours();\n      return `${year}-${month}-${day} ${hour}:00`;\n    };\n  }\n\n  if (format === \"month_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { month: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any year, starting at january\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2001-01-01\").getTime()];\n  }\n  if (format === \"weekday_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { weekday: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any full week, starting at monday\n    domain = [new Date(\"2023-11-06\").getTime(), new Date(\"2023-11-13\").getTime()];\n  }\n  if (format === \"hour_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { hour: \"numeric\", hour12: false });\n      return intlFormatter.format(date);\n    };\n    // can be any day, starting at midnight\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2000-01-02\").getTime()];\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)));\n  if (domain == null) domain = getDomain(dateNumbers);\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter);\n\n  return [formattedDate, sortableDate];\n}\n\nfunction autoFormatDate(dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers);\n\n  let autoFormat: DateFormat = \"hour\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = \"day\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = \"month\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = \"quarter\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = \"year\";\n\n  return autoFormat;\n}\n\nfunction createSortable(\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {};\n  const [minTime, maxTime] = domain;\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0;\n  if (interval === \"year\") intervalNumber = 1000 * 60 * 60 * 24 * 364;\n  if (interval === \"quarter\") intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3;\n  if ([\"month\", \"month_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28;\n  if ([\"day\", \"weekday_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24;\n  if ([\"hour\", \"hour_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60;\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i);\n      const datestring = formatter(date);\n      if (sortable[datestring] !== undefined) continue;\n      sortable[datestring] = i;\n    }\n  }\n\n  return sortable;\n}\n\nfunction getDomain(numbers: number[]): [number, number] {\n  let min = numbers[0];\n  let max = numbers[0];\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr;\n    if (nr > max) max = nr;\n  });\n  return [min, max];\n}\n\nexport function tokenize(text: string): string[] {\n  const tokens = text.split(\" \");\n  return tokens.filter((token) => /\\p{L}/giu.test(token)); // only tokens with word characters\n}\n\nexport function getTableColumn(table: Table, column: string): string[] {\n  if (column === \".COUNT\") {\n    // special case: just return array with values of 1\n    return Array(table.body.rows.length).fill(\"1\");\n  }\n  const columnIndex = table.head.cells.findIndex((cell) => cell === column);\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`);\n  return table.body.rows.map((row) => row.cells[columnIndex]);\n}\n\nexport function rescaleToRange(value: number, min: number, max: number, newMin: number, newMax: number): number {\n  let scaled = (value - min) / (max - min);\n  scaled = isNaN(scaled) ? 0 : scaled; // prevent NaN\n  return scaled * (newMax - newMin) + newMin;\n}\n\nexport function extractUrlDomain(x: string): string {\n  let domain;\n  try {\n    const url = new URL(x);\n    domain = url.hostname.replace(/^www\\./, \"\").replace(/^m\\./, \"\");\n  } catch (_) {\n    domain = x;\n  }\n  return domain.trim();\n}\n","import { formatDate, getTableColumn } from './util'\nimport { Table, TickerFormat, ChartVisualizationData, ChartVisualization, AxisSettings } from '../types'\n\nexport async function prepareChartData (\n  table: Table,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return { type: visualization.type, xKey: '', xLabel: '', yKeys: {}, data: [] }\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(table, visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  table: Table,\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = initializeVisualizationData(table, visualization)\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xKey]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction initializeVisualizationData (table: Table, visualization: ChartVisualization): ChartVisualizationData {\n  const yKeys: Record<string, AxisSettings> = {}\n  for (const value of visualization.values) {\n    let tickerFormat: TickerFormat = 'default'\n    if (value.aggregate === 'pct' || value.aggregate === 'count_pct') tickerFormat = 'percent'\n\n    if (value.group_by === undefined) {\n      const label = value.label !== undefined ? value.label : value.column\n      yKeys[value.column] = { id: value.column, label, tickerFormat }\n    } else {\n      const uniqueValues = Array.from(new Set(getTableColumn(table, value.group_by)))\n      for (const uniqueValue of uniqueValues) {\n        const id = `${value.column}.GROUP_BY.${uniqueValue}`\n        yKeys[id] = { id, label: uniqueValue, tickerFormat }\n      }\n    }\n  }\n\n  return {\n    type: visualization.type,\n    xKey: visualization.group.column,\n    xLabel: visualization.group.label,\n    yKeys,\n    data: []\n  }\n}\n\nfunction aggregateData (table: Table, visualization: ChartVisualization): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xKey = visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xKey,\n        xValue: uniqueValue,\n        values: {}\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by\n    // column values. As suffix we use the value column, separated with .GROUP_BY.. This is used\n    // so that we can relate the aggregated data back to the value specification\n    let yGroup: null | string[] = null\n    if (value.group_by !== undefined) { yGroup = getTableColumn(table, value.group_by).map((v) => `${value.column}.GROUP_BY.${v}`) }\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (Number(xValue) < visualization.group.range[0] || Number(xValue) > visualization.group.range[1]) {\n          continue\n        }\n      }\n\n      const yValue = yValues[i]\n      const group = yGroup != null ? yGroup[i] : value.column\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xKey,\n          xValue: String(xValue),\n          values: {}\n        }\n      }\n\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] = Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: Table,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xKey: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  tickerFormat?: TickerFormat\n}\n","import { extractUrlDomain, getTableColumn, tokenize } from './util'\nimport { TextVisualizationData, TextVisualization, ScoredTerm, Table } from '../types'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (table: Table, visualization: TextVisualization): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values = visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens = visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (let token of tokens) {\n      if (visualization.extract === 'url_domain') token = extractUrlDomain(token)\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n\n      const v = values != null ? Number(values[i]) ?? 1 : 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (vocabulary: Record<string, VocabularyStats>, nDocs: number, topTerms: number): ScoredTerm[] {\n  return Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = stats.value\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n}\n","import { ChartVisualization, TextVisualization, VisualizationType, VisualizationData, Table } from '../types'\nimport { prepareChartData } from './prepareChartData'\nimport { prepareTextData } from './prepareTextData'\n\ninterface Input {\n  table: Table\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (table: Table, visualization: VisualizationType): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["formatDate","dateString","format","minValues","arguments","length","undefined","formattedDate","dateNumbers","map","date","Date","getTime","domain","formatter","toISOString","minTime","maxTime","getDomain","autoFormat","autoFormatDate","getFullYear","toString","year","quarter","Math","floor","getMonth","concat","month","toLocaleString","day","getDate","hour","getHours","Intl","DateTimeFormat","weekday","hour12","sortableDate","interval","sortable","intervalNumber","includes","i","datestring","createSortable","numbers","min","max","forEach","nr","tokenize","text","split","filter","token","test","getTableColumn","table","column","Array","body","rows","fill","columnIndex","head","cells","findIndex","cell","Error","id","row","extractUrlDomain","x","URL","hostname","replace","_","trim","async","prepareChartData","visualization","type","xKey","xLabel","yKeys","data","aggregate","groupBy","xSortable","group","dateFormat","levels","prepareX","rowIds","anyAddZeroes","values","some","value","addZeroes","uniqueValue","sortby","Object","entries","sortBy","xValue","_value$addZeroes","aggFun","yValues","yGroup","group_by","v","groupSummary","_Number","range","Number","yValue","_Number2","n","sum","String","push","keys","aggregateData","visualizationData","tickerFormat","label","uniqueValues","from","Set","initializeVisualizationData","sort","a","b","d","key","round","__rowIds","__sortBy","createVisualizationData","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","extract","docFreq","has","add","isNaN","getVocabulary","valueColumn","nDocs","_ref","stats","tf","idf","log","importance","slice","getTopTerms","self","onmessage","e","then","postMessage","status","catch","error","console"],"sourceRoot":""}